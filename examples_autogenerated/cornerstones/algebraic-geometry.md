---
layout: page
title: Commutative Algebra and Algebraic Geometry
---

## Authors: Janko Böhm, Wolfram Decker and Frank-Olaf Schreyer

```julia
julia> R, (x, y, z) = polynomial_ring(QQ, ["x", "y", "z"]);

julia> I = ideal(R, [x^2+y^2+2*z^2-8, x^2-y^2-z^2+1, x-y+z]);

julia> groebner_basis(I, ordering = lex(R), complete_reduction = true)
Gröbner basis with elements
1 -> 6*z^4 - 18*z^2 + 1
2 -> y + 3*z^3 - 9*z
3 -> x + 3*z^3 - 8*z
with respect to the ordering
lex([x, y, z])
```

```julia
julia> normal_form(x^2+y^2+z^2, I, ordering = lex(R))
-z^2 + 8
```

```julia
julia> S, (x, y) = graded_polynomial_ring(QQ, ["x", "y"], [1, 2]);

julia> default_ordering(S)
wdegrevlex([x, y], [1, 2])
```

```julia
julia> R, (x, y, z) = polynomial_ring(QQ, ["x", "y", "z"]);

julia> I = ideal(R, [x*y, y*z]);

julia> minimal_primes(I)
2-element Vector{MPolyIdeal{QQMPolyRingElem}}:
 Ideal (z, x)
 Ideal (y)

julia> J = ideal(R, [x^2+1])^2;

julia> primary_decomposition(J)
1-element Vector{Tuple{MPolyIdeal{QQMPolyRingElem}, MPolyIdeal{QQMPolyRingElem}}}:
 (Ideal (x^4 + 2*x^2 + 1), Ideal (x^2 + 1))

julia> L = absolute_primary_decomposition(J)
1-element Vector{Tuple{MPolyIdeal{QQMPolyRingElem}, MPolyIdeal{QQMPolyRingElem}, MPolyIdeal{AbstractAlgebra.Generic.MPoly{AbsSimpleNumFieldElem}}, Int64}}:
 (Ideal (x^4 + 2*x^2 + 1), Ideal (x^2 + 1), Ideal (x - _a), 2)

julia> base_ring(L[1][3])
Multivariate polynomial ring in 3 variables x, y, z
  over number field of degree 2 over QQ
```

```julia
julia> R, (x1, x2, x3) = polynomial_ring(QQ, ["x1", "x2", "x3"]);

julia> I = ideal(R, [x2 - x1^2, x3 - x1*x2]);

julia> radical(leading_ideal(I))
Ideal generated by
  x2
  x1

julia> dim(I)
1
```

```julia
julia> R, (x, y, t) = polynomial_ring(QQ, ["x", "y", "t"]);

julia> I = ideal(R, [x^2 + y^2 - 1, y - t*x - 1]);

julia> Gy = groebner_basis(I, ordering = lex([y, x, t]), complete_reduction=true)
Gröbner basis with elements
1 -> x^2*t^2 + x^2 + 2*x*t
2 -> y - x*t - 1
with respect to the ordering
lex([y, x, t])

julia> factor(Gy[1])
1 * (x*t^2 + x + 2*t) * x

julia> Gx = groebner_basis(I, ordering = lex([x, y, t]), complete_reduction=true)
Gröbner basis with elements
1 -> y^2*t^2 + y^2 - 2*y - t^2 + 1
2 -> x*t - y + 1
3 -> x*y - x + y^2*t - t
4 -> x^2 + y^2 - 1
with respect to the ordering
lex([x, y, t])

julia> factor(Gx[1])
1 * (y - 1) * (y*t^2 + y + t^2 - 1)
```

```julia
julia> R, (x, y) = polynomial_ring(QQ, ["x", "y"]);

julia> f = y^2-x^3;

julia> g = 2*y^2-x^3;

julia> U = complement_of_point_ideal(R, [0 ,0]);

julia> Rloc, _ = localization(R, U);

julia> I = ideal(Rloc, [f, g]);

julia> A, _ = quo(Rloc, I);

julia> vector_space_dimension(A)
6

julia> C = plane_curve(f)
Affine plane curve
  defined by 0 = x^3 - y^2

julia> D = plane_curve(g);

julia> P = D([0, 0])
Rational point
  of scheme(x^3 - 2*y^2)
with coordinates (0, 0)

julia> intersection_multiplicity(C, D, P)
6
```

```julia
julia> R, (x, y) = polynomial_ring(QQ, ["x", "y"]);

julia> f = -3*x^5 - 2*x^4*y - 3*x^3*y^2 + x*y^4 + 3*y^5 + 6*x^4 + 7*x^3*y + 3*x^2*y^2 - 2*x*y^3 - 6*y^4 - 3*x^3 - 5*x^2*y + x*y^2 + 3*y^3;

julia> A, _ = quo(R, ideal(R, [f]));

julia> L = normalization_with_delta(A);

julia> L[3]
6
```

```julia
julia> R, (x1, x2, x3) = polynomial_ring(QQ, ["x1", "x2", "x3"]);

julia> I = ideal(R, [x2 - x1^2, x3 - x1*x2]);

julia> H = homogenizer(R, "x0"; pos=1);

julia> J = H(I)
Ideal generated by
  -x1*x3 + x2^2
  -x0*x3 + x1*x2
  -x0*x2 + x1^2
```

```julia
julia> J1 = ideal([H(I[1]), H(I[2])])
Ideal generated by
  x0*x2 - x1^2
  x0*x3 - x1*x2

julia> MP = minimal_primes(J1)
2-element Vector{MPolyIdeal{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}}:
 Ideal (x1*x3 - x2^2, x0*x3 - x1*x2, x0*x2 - x1^2)
 Ideal (x1, x0)

julia> J in MP
true
```

```julia
julia> pt = radical(J+ideal([base_ring(J)[1]]))
Ideal generated by
  x2
  x1
  x0
```

```julia
julia> R, (x, y) = polynomial_ring(QQ, ["x", "y"]);

julia> f = (x-y)*((x+y)^2-(x-y)^3)-(x+y)^4;

julia> g = y^2-x^2+3*x^3;

julia> H = homogenizer(R, "z");

julia> F = H(f);

julia> G = H(g);

julia> I = ideal([F, G]);

julia> degree(radical(I))
5

julia> cI = primary_decomposition(I);

julia> degrees = map(comp -> degree(comp[1]), cI)
2-element Vector{ZZRingElem}:
 4
 8

julia> pos = findfirst(deg -> deg == 8, degrees)
2

julia> cI[pos][2]
Ideal generated by
  y
  x
```

```julia
julia> cIabs = absolute_primary_decomposition(I);

julia> pos_abs = findfirst(cp -> degree(cp[1]) == 8, cIabs)
2

julia> degree(cIabs[pos_abs][1])
8

julia> other_pos_abs = pos_abs == 1 ? 2 : 1
1

julia> cI2 = cIabs[other_pos_abs][3]
Ideal generated by
  648*y + (-160*_a^3 - 1269*_a^2 + 22446*_a + 972)*z
  184147758075888*x + (2850969000960*_a^3 + 22611747888864*_a^2 - 399955313722176*_a - 17319636680832)*y + (2884707374400*_a^3 + 2
  2782606070410*_a^2 - 405172045313820*_a - 57843867366864)*z

julia> R2 = base_ring(cI2)
Multivariate polynomial ring in 3 variables over number field graded by
  x -> [1]
  y -> [1]
  z -> [1]

julia> K = coefficient_ring(R2)
Number field with defining polynomial 160*x^4 + 1269*x^3 - 22446*x^2 - 972*x - 648
  over rational field

julia> a = gen(K);

julia> mp =  minpoly(a)
x^4 + 1269//160*x^3 - 11223//80*x^2 - 243//40*x - 81//20

julia> S, (x,) = polynomial_ring(QQ, ["x"]);

julia> g = mp(x);

julia> sols, _ = real_solutions(ideal([g]));

julia> length(sols)
2
```

```julia
julia> P, (x, y, z) = graded_polynomial_ring(QQ, ["x", "y", "z"]);

julia> f = x^5 + 10*x^4*y + 20*x^3*y^2 + 130*x^2*y^3 - 20*x*y^4 + 20*y^5 - 2*x^4*z - 40*x^3*y*z - 150*x^2*y^2*z - 90*x*y^3*z - 40*y^4*z + x^3*z^2 + 30*x^2*y*z^2 + 110*x*y^2*z^2 + 20*y^3*z^2;

julia> C = plane_curve(f)
Projective plane curve
  defined by 0 = x^5 + 10*x^4*y - 2*x^4*z + 20*x^3*y^2 - 40*x^3*y*z + x^3*z^2 + 130*x^2*y^3 - 150*x^2*y^2*z + 30*x^2*y*z^2 - 20*x*
  y^4 - 90*x*y^3*z + 110*x*y^2*z^2 + 20*y^5 - 40*y^4*z + 20*y^3*z^2

julia> conics = [x^2-x*z, y^2-y*z];

julia> BM = invert_birational_map(conics, C);

julia> phi = BM["inverse"]
3-element Vector{QQMPolyRingElem}:
 -10*y(1)^5 - 430*y(1)^4*y(2) - 5020*y(1)^3*y(2)^2 - 15100*y(1)^2*y(2)^3 - 4800*y(1)*y(2)^4 - 400*y(2)^5
 y(1)^5 + 50*y(1)^4*y(2) + 690*y(1)^3*y(2)^2 + 1620*y(1)^2*y(2)^3 - 1800*y(1)*y(2)^4 - 400*y(2)^5
 y(1)^5 - 60*y(1)^4*y(2) - 2240*y(1)^3*y(2)^2 - 18100*y(1)^2*y(2)^3 - 4800*y(1)*y(2)^4 - 400*y(2)^5

julia> evaluate(defining_equation(C), phi)
0

julia> I = adjoint_ideal(C)
Ideal generated by
  y^3 - y^2*z
  x*y^2 - x*y*z
  x^2*y - x*y*z
  x^3 - x^2*z

julia> D = Oscar.map_to_rational_normal_curve(C)
Projective curve
  in projective 3-space over QQ with coordinates [y(1), y(2), y(3), y(4)]
defined by ideal with 3 generators

julia> betti(free_resolution(defining_ideal(D)))
       0  1
-----------
2    : 3  2
-----------
total: 3  2


julia> Oscar.rat_normal_curve_anticanonical_map(D)
2-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:
 2*y(2) + 13*y(4)
 y(4)

julia> rational_point_conic(plane_curve(y^2 - x*z))
3-element Vector{QQMPolyRingElem}:
 0
 0
 -1

julia> I = parametrization(C)
3-element Vector{QQMPolyRingElem}:
 25*s^5 - 1025*s^4*t + 14825*s^3*t^2 - 85565*s^2*t^3 + 146420*s*t^4 - 20780*t^5
 25*s^5 - 1400*s^4*t + 30145*s^3*t^2 - 305650*s^2*t^3 + 1396410*s*t^4 - 2023972*t^5
 25*s^5 - 1025*s^4*t + 15575*s^3*t^2 - 116205*s^2*t^3 + 562440*s*t^4 - 1898652*t^5
```

```julia
julia> R, (x0, x1, x2, x3) = polynomial_ring(QQ, ["x0", "x1", "x2", "x3"]);

julia> I = ideal([x0, x1]);

julia> J = ideal([x2, x3]);

julia> A = matrix(R, [1 x0 x1 0 0; 1 0 0 x2 x3])
[1   x0   x1    0    0]
[1    0    0   x2   x3]

julia> B = transpose(syz(transpose(A)))
[  0     0   x1*x3   x0*x3   x1*x2   x0*x2]
[  0   -x1       0     -x3       0     -x2]
[  0    x0     -x3       0     -x2       0]
[-x3     0       0       0     -x1     -x0]
[ x2     0     -x1     -x0       0       0]

julia> intersect(I,J)
Ideal generated by
  x1*x3
  x0*x3
  x1*x2
  x0*x2
```

```julia
julia> R, (w, x, y, z) = graded_polynomial_ring(QQ, ["w", "x", "y", "z"]);

julia> I = ideal([w^2-x*z,w*x-y*z,x^2-w*y,x*y-z^2,y^2-w*z]);

julia> A, _ = quo(R, I);

julia> FA = free_resolution(A)
Free resolution of A
R^1 <---- R^5 <---- R^6 <---- R^2 <---- 0
0         1         2         3         4

julia> FA[1]
Graded free module R^5([-2]) of rank 5 over R

julia> FA[2]
Graded free module R^5([-3]) + R^1([-4]) of rank 6 over R

julia> FA[3]
Graded free module R^1([-4]) + R^1([-5]) of rank 2 over R

julia> map(FA,1)
R^5 -> R^1
e[1] -> (-w*z + y^2)*e[1]
e[2] -> (x*y - z^2)*e[1]
e[3] -> (-w*y + x^2)*e[1]
e[4] -> (w*x - y*z)*e[1]
e[5] -> (w^2 - x*z)*e[1]
Homogeneous module homomorphism

julia> map(FA,2)
R^6 -> R^5
e[1] -> -x*e[1] + y*e[2] - z*e[4]
e[2] -> w*e[1] - x*e[2] + y*e[3] + z*e[5]
e[3] -> -w*e[3] + x*e[4] - y*e[5]
e[4] -> z*e[1] - w*e[2] + y*e[4]
e[5] -> z*e[3] - w*e[4] + x*e[5]
e[6] -> (-w^2 + x*z)*e[1] + (-w*z + y^2)*e[5]
Homogeneous module homomorphism

julia> map(FA,3)
R^2 -> R^6
e[1] -> -w*e[2] - y*e[3] + x*e[4] - e[6]
e[2] -> (-w^2 + x*z)*e[1] + y*z*e[2] + z^2*e[3] - w*y*e[4] + (w*z - y^2)*e[5] + x*e[6]
Homogeneous module homomorphism
```

```julia
julia> R, (w,x,y,z) = graded_polynomial_ring(QQ, ["w", "x", "y", "z"]);

julia> I = ideal(R, [x*w-y*z, y*w-(x-z)*(x-2*z)]);

julia> Q = projective_scheme(I);

julia> is_smooth(Q)
true

julia> hilbert_polynomial(Q)
4*t

julia> degree(Q)
4

julia> arithmetic_genus(Q)
1
```

```julia
julia> betti_table(FA)
       0  1  2  3
-----------------
0    : 1  -  -  -
1    : -  5  5  1
2    : -  -  1  1
-----------------
total: 1  5  6  2


julia> minimal_betti_table(FA)
       0  1  2  3
-----------------
0    : 1  -  -  -
1    : -  5  5  -
2    : -  -  -  1
-----------------
total: 1  5  5  1
```

```julia
julia> S, x = graded_polynomial_ring(QQ, ["x_0", "x_1", "x_2", "x_3"]);

julia> m3x3 = matrix(S, 3, 3, [(i + j == 4) ? 0 : x[4 - (i + j)] for i in 0:2, j in 0:2])
[x_3   x_2   x_1]
[x_2   x_1   x_0]
[x_1   x_0     0]

julia> f = det(m3x3[1:2, 1:2])
x_1*x_3 - x_2^2

julia> g = det(m3x3)
-x_0^2*x_3 + 2*x_0*x_1*x_2 - x_1^3

julia> leading_term(f)
-x_2^2

julia> leading_term(g)
-x_1^3

julia> J = ideal([f, g]);

julia> p1 = radical(J);

julia> p1 == ideal(minors(m3x3[1:3, 1:2],2))
true

julia> mp1 = ideal_as_module(p1)
Graded submodule of S^1
1 -> (-x_1*x_3 + x_2^2)*e[1]
2 -> (-x_0*x_3 + x_1*x_2)*e[1]
3 -> (-x_0*x_2 + x_1^2)*e[1]
represented as subquotient with no relations

julia> M1, _ = quo(ambient_free_module(mp1), mp1);

julia> M1
Graded subquotient of submodule of S^1 generated by
1 -> e[1]
by submodule of S^1 generated by
1 -> (-x_1*x_3 + x_2^2)*e[1]
2 -> (-x_0*x_3 + x_1*x_2)*e[1]
3 -> (-x_0*x_2 + x_1^2)*e[1]

julia> mJ = ideal_as_module(J);

julia> M, _  = quo(ambient_free_module(mJ),mJ);

julia> homM1M, psi = hom(M1, M);

julia> hom1, tohomM1M = prune_with_map(homM1M);

julia> hom1
Graded subquotient of submodule of S^2 generated by
1 -> e[1]
2 -> e[2]
by submodule of S^2 generated by
1 -> -x_2*e[1] + x_3*e[2]
2 -> x_0*e[1] - x_1*e[2]
3 -> -x_1*e[1] + x_2*e[2]

julia> degrees_of_generators(hom1)
2-element Vector{FinGenAbGroupElem}:
 [2]
 [2]

julia> phi1 = psi(tohomM1M(hom1[1]))
M1 -> M
e[1] -> (-x_0*x_3 + x_1*x_2)*e[1]
Graded module homomorphism of degree [2]


julia> phi2 = psi(tohomM1M(hom1[2]))
M1 -> M
e[1] -> (-x_0*x_2 + x_1^2)*e[1]
Graded module homomorphism of degree [2]


julia> kerphi2, _ = kernel(phi2);

julia> iszero(kerphi2)
true

julia> MmodM1 = cokernel(phi2)
Graded subquotient of submodule of S^1 generated by
1 -> e[1]
by submodule of S^1 generated by
1 -> (x_1*x_3 - x_2^2)*e[1]
2 -> (-x_0^2*x_3 + 2*x_0*x_1*x_2 - x_1^3)*e[1]
3 -> (-x_0*x_2 + x_1^2)*e[1]

julia> p2 = ideal([x[1],x[2],x[3]])
Ideal generated by
  x_0
  x_1
  x_2

julia> f = x[2]*x[3]-x[1]*x[4]
-x_0*x_3 + x_1*x_2

julia> v = f*MmodM1[1];

julia> U, inclU = sub(MmodM1, [v]);

julia> annihilator(U) == p2
true

julia> mp2 = ideal_as_module(p2);

julia> Smodp2, _ = quo(ambient_free_module(mp2), mp2);

julia> homp2M1, tau = hom(Smodp2, MmodM1);

julia> hom2, tohomp2M1 = prune_with_map(homp2M1);

julia> psi = tau(tohomp2M1(hom2[1]));

julia> iszero(kernel(psi)[1])
true

julia> annihilator(cokernel(psi))
Ideal generated by
  -x_1*x_3 + x_2^2
  -x_0*x_3 + x_1*x_2
  -x_0*x_2 + x_1^2

julia> annihilator(cokernel(psi)) == p1
true
```

```julia
julia> S, (x0, x1, x2, x3, x4) = graded_polynomial_ring(GF(3), ["x0", "x1", "x2", "x3", "x4"]);

julia> m = ideal(S, [x1^2+(-x1+x2+x3-x4)*x0, x1*x2+(x1-x3+x4)*x0, x1*x3+(-x1+x4+x0)*x0, x1*x4+(-x1+x3+x4-x0)*x0, x2^2+(x1-x2-x4-x0)*x0, x2*x3+(x1-x2+x3+x4-x0)*x0, x2*x4+(x1+x2-x3-x4-x0)*x0, x3^2+(x3+x4-x0)*x0,x3*x4+(-x3-x4+x0)*x0, x4^2+(x1+x3-x4-x0)*x0]);

julia> Qm, _ = quo(S, m);

julia> FQm = free_resolution(Qm, algorithm = :mres);

julia> betti_table(FQm)
       0   1   2   3   4  5
---------------------------
0    : 1   -   -   -   -  -
1    : -  10  15   2   -  -
2    : -   -   7  26  20  5
---------------------------
total: 1  10  22  28  20  5
```

```julia
julia> phi = map(FQm, 3);

julia> M = transpose(matrix(phi)[1:2, 1:15]);

julia> DM = [map_entries(x->derivative(x,i), M) for i = 1:5];

julia> MM = transpose(hcat(DM...));

julia> size(MM)
(10, 15)

julia> NN = matrix(map(FQm, 2))[1:15, 1:10];

julia> size(NN)
(15, 10)

julia> D = graded_cokernel(transpose(MM*NN));

julia> FD = free_resolution(D, algorithm = :mres);

julia> betti_table(FD)
        0   1  2
----------------
0    : 10  10  -
1    :  -   -  1
2    :  -   -  -
3    :  -   -  1
----------------
total: 10  10  2


julia> P = cokernel(transpose(matrix(map(FD, 2))));

julia> I = annihilator(P);

julia> QI, _ = quo(S, I);

julia> FQI = free_resolution(QI, algorithm = :mres);

julia> betti_table(FQI)
       0   1   2   3  4
-----------------------
0    : 1   -   -   -  -
1    : -   -   -   -  -
2    : -   -   -   -  -
3    : -   -   -   -  -
4    : -   5   -   -  -
5    : -   7  26  20  5
-----------------------
total: 1  12  26  20  5


julia> dim(I)
3

julia> degree(I)
11

julia> MI = ideal_as_module(I);

julia> sheaf_cohomology(MI, -2, 8, algorithm = :loccoh)
twist:   -2   -1    0    1    2    3    4    5    6    7    8
-------------------------------------------------------------
4:        -    -    -    -    -    -    -    -    -    -    -
3:       30   10    -    -    -    -    -    -    -    -    -
2:        -    -    -    2    -    -    -    -    -    -    -
1:        -    -    -    -    1    5    5    -    -    -    -
0:        -    -    -    -    -    -    -    5   32   84  170
-------------------------------------------------------------
chi:     30   10    -    2    1    5    5    5   32   84  170

julia> sheaf_cohomology(MI, -2, 8)
twist:   -2   -1    0    1    2    3    4    5    6    7    8
-------------------------------------------------------------
4:        -    -    -    -    -    -    -    *    *    *    *
3:        *   10    -    -    -    -    -    -    *    *    *
2:        *    *    -    2    -    -    -    -    -    *    *
1:        *    *    *    -    1    5    5    -    -    -    *
0:        *    *    *    *    -    -    -    5   32   84  170
-------------------------------------------------------------
chi:      *    *    *    *    1    5    5    *    *    *    *
```

```julia
julia> X = rational_d9_pi6();

julia> is_smooth(X)
true

julia> degree(X)
9

julia> S = ambient_coordinate_ring(X)
Multivariate polynomial ring in 5 variables over GF(31991) graded by
  x -> [1]
  y -> [1]
  z -> [1]
  u -> [1]
  v -> [1]

julia> B, _ = quo(S, ideal(S, [gens(S)[1]]));

julia> Y = proj(B)
Projective scheme
  over finite field of characteristic 31991
defined by ideal (x)

julia> C = intersect(X, Y);

julia> arithmetic_genus(C)
6

julia> A = homogeneous_coordinate_ring(X);

julia> FA = free_resolution(A);

julia> minimal_betti_table(FA)
       0   1   2   3  4
-----------------------
0    : 1   -   -   -  -
1    : -   -   -   -  -
2    : -   -   -   -  -
3    : -   -   -   -  -
4    : -  15  26  15  3
5    : -   1   3   3  1
-----------------------
total: 1  16  29  18  4


julia> I = defining_ideal(X);

julia> IQ = ideal([x for x in gens(I) if degree(x)[1] == 5]);

julia> J = saturation(IQ, I);

julia> degree(J)
1

julia> M = I + J;

julia> degree(M)
6
```

```julia
function dual_curve(f::MPolyRingElem, P_dual::MPolyRing)
  P = parent(f)
  vars_P = gens(P)
  nvars_P = ngens(P)
  vars_P_dual = gens(P_dual)
  # Extend the original polynomial ring to include the variables of P_dual
  P_ext, vars_ext = polynomial_ring(base_ring(P), [[string(v) for v in vars_P]; [string(v) for v in vars_P_dual]])
  inc = hom(P, P_ext, vars_ext[1:nvars_P])
  f_ext = inc(f)
  # Compute the Jacobian matrix with respect to the original variables
  jf = transpose(jacobian_matrix(f_ext)[1:nvars_P, 1:1])
  # Form the matrix with the last 'ngens(P_dual)' variables of P_ext
  A = matrix([vars_ext[(end-ngens(P_dual)+1):end]])
  # Stack the Jacobian matrix and the matrix A
  m2x3 = vcat(jf, A)
  # Compute minors and saturate
  I = ideal(minors(m2x3, 2))
  J = ideal([jf[1, i] for i in 1:ncols(jf)])
  Isat = saturation(I + ideal([f_ext]), J)
  # Project to the dual space
  proj_dual_images = vcat([zero(P_dual) for _ in 1:nvars_P], gens(P_dual))
  proj = hom(P_ext, P_dual, proj_dual_images)
  dual_curve = groebner_basis(proj(Isat))
  return dual_curve[1]
end

```

```julia
julia> P, (x, y, z) = graded_polynomial_ring(QQ, ["x", "y", "z"]);

julia> f = 8*x^4+20*x^2*y^2+8*y^4-48*x^2*z^2-48*y^2*z^2+65*z^4;

julia> P_dual, (u, v, w) = graded_polynomial_ring(QQ, ["u", "v", "w"]);

julia> f_dual = dual_curve(f, P_dual)
101920*u^12 - 283920*u^10*v^2 - 424704*u^10*w^2 - 329160*u^8*v^4 - 420192*u^8*v^2*w^2 + 701152*u^8*w^4 + 1211860*u^6*v^6 - 200976*u^6*v^4*w^2 + 1603016*u^6*v^2*w^4 - 585600*u^6*w^6 - 329160*u^4*v^8 - 200976*u^4*v^6*w^2 + 1873041*u^4*v^4*w^4 - 1405488*u^4*v^2*w^6 + 261000*u^4*w^8 - 283920*u^2*v^10 - 420192*u^2*v^8*w^2 + 1603016*u^2*v^6*w^4 - 1405488*u^2*v^4*w^6 + 489600*u^2*v^2*w^8 - 58752*u^2*w^10 + 101920*v^12 - 424704*v^10*w^2 + 701152*v^8*w^4 - 585600*v^6*w^6 + 261000*v^4*w^8 - 58752*v^2*w^10 + 5184*w^12

julia> f1 = x^4+y^3*z-y*z^3;

julia> f1_dual = dual_curve(f1, P_dual);

julia> f1_dual(u,1,w)
4*u^12 - 48*u^8*w^3 + 48*u^8*w - 27*u^4*w^8 + 84*u^4*w^6 - 546*u^4*w^4 + 84*u^4*w^2 - 27*u^4 - 256*w^9 + 768*w^7 - 768*w^5 + 256*w^3

julia> f2 = x^4+y^3*z-y*z^3-2//9*x^2*z^2+1//81*z^4;

julia> f2_dual = dual_curve(f2, P_dual);

julia> f2_dual(u,1,w)
235953*u^12 + 8748*u^10*w^2 + 314928*u^10*w + 2916*u^10 - 118098*u^8*w^4 - 2834352*u^8*w^3 + 8748*u^8*w^2 + 2831760*u^8*w - 1458*u^8 + 708588*u^6*w^6 - 866052*u^6*w^4 + 90720*u^6*w^3 + 3700404*u^6*w^2 + 33696*u^6*w + 235940*u^6 - 1594323*u^4*w^8 + 4960116*u^4*w^6 - 1189728*u^4*w^5 - 32240754*u^4*w^4 + 46656*u^4*w^3 + 4967028*u^4*w^2 + 303264*u^4*w - 1589715*u^4 + 6928416*u^2*w^7 - 8188128*u^2*w^5 - 62208*u^2*w^4 + 3149280*u^2*w^3 - 1889568*u^2*w - 20736*u^2 - 15116544*w^9 + 45349632*w^7 + 186624*w^6 - 45349632*w^5 - 373248*w^4 + 15116544*w^3 + 186624*w^2
```

```julia
julia> P2, (x, y, z) = polynomial_ring(QQ,["x","y","z"]);

julia> f1 = 8*x^4+20*x^2*y^2+8*y^4-48*x^2*z^2-48*y^2*z^2+65*z^4+x*y^3;

julia> f2 = x^3*y+y^3*z+z^3*x+x^4;

julia> g1 = 1771*f1 - 1317*f2;

julia> hess1 = hessian(g1);

julia> I1 = ideal([hess1,g1]);

julia> g1yz = eliminate(I1,[x]);

julia> Q, t = polynomial_ring(QQ,"y");

julia> phi = hom(P2, Q, [0,t,1]);

julia> g1t = phi(g1yz[1]);

julia> G1,_ = galois_group(g1t);

julia> G1
Sym(24)

julia> g2 = 7713*f1 - 1313*f2;

julia> g2t = phi(eliminate(ideal([hessian(g2),g2]),[x])[1]);

julia> G2,_ = galois_group(g2t);

julia> G2==G1
true

julia> dg1 = discriminant(g1t);

julia> dg2 = discriminant(g2t);

julia> ggT = gcd(dg1,dg2);

julia> factor(ZZ(ggT))
1 * 2^4

julia> KK, _ = number_field(g2t);

julia> degree(KK)
24

julia> O = any_order(KK);

julia> OO = pmaximal_overorder(O, 2);

julia> d = discriminant(OO);

julia> gcd(d,2)
1
```

```julia
julia> Rt, (x,y,t) = polynomial_ring(QQ, ["x","y","t"]);

julia> ft = -2*x^6 - 5*x^5*y*t + 8*x^5*t - 3*x^5 + 10*x^4*y^2*t^2 - 2*x^4*y^2*t + 10*x^4*y*t^2 - 12*x^4*y*t - 8*x^4*t^2 + 12*x^4*t + 24*x^3*y^3*t^2 + 14*x^3*y^3*t + 20*x^3*y^2*t^2 + 6*x^3*y^2*t + 24*x^3*y*t^2 + x^3*y*t - 12*x^3*t^2 + 10*x^2*y^4*t^2 - 2*x^2*y^4*t + 20*x^2*y^3*t^2 + 6*x^2*y^3*t - 44*x^2*y^2*t^2 - 20*x^2*y^2*t - 2*x^2*y*t^2 + x^2*y - 5*x*y^5*t + 10*x*y^4*t^2 - 12*x*y^4*t + 24*x*y^3*t^2 + x*y^3*t - 2*x*y^2*t^2 + x*y^2 - 2*x*y*t - 2*y^6 + 8*y^5*t - 3*y^5 - 8*y^4*t^2 + 12*y^4*t - 12*y^3*t^2;

julia> R, (x,y) = polynomial_ring(QQ, ["x","y"]);

julia> phi0 = hom(Rt,R,[x,y,0]);

julia> f = phi0(ft);

julia> H = homogenizer(R, "z");

julia> F = H(f);

julia> S = parent(F);

julia> C = plane_curve(F);

julia> I = adjoint_ideal(C)
Ideal generated by
  x*y - y^2
  x^2 - y^2
  y^3 + y^2*z

julia> m3 = ideal(gens(S))^3;

julia> K = intersect(I, m3)
Ideal generated by
  x*y*z - y^2*z
  x^2*z - y^2*z
  y^3 + y^2*z
  x*y^2 + y^2*z
  x^2*y + y^2*z
  x^3 + y^2*z

julia> P5, _ = graded_polynomial_ring(QQ, ["x_0", "x_1", "x_2", "x_3", "x_4", "x_5"]);

julia> PC, pr = quo(S, ideal([F]));

julia> psi = hom(P5, PC, [pr(K[i]) for i = 1:6]);

julia> J = kernel(psi);

julia> JJ = ideal(minimal_generating_set(J));

julia> Q , _ = quo(P5, JJ);

julia> re = free_resolution(Q);

julia> minimal_betti_table(re)
       0  1   2  3  4
---------------------
0    : 1  -   -  -  -
1    : -  6   8  3  -
2    : -  3   8  6  -
3    : -  -   -  -  1
---------------------
total: 1  9  16  9  1


julia> phi1 = hom(Rt,R,[x,y,R(1//10)]);

julia> f = phi1(ft);

julia> F = H(f);

julia> C = plane_curve(F);

julia> I = adjoint_ideal(C)
Ideal generated by
  6*x*y - 5*y^2 + y*z
  5*x^2 - x*z - 5*y^2 + y*z

julia> m3 = ideal(gens(S))^3;

julia> K = intersect(I, m3)
Ideal generated by
  6*x*y*z - 5*y^2*z + y*z^2
  5*x^2*z - x*z^2 - 5*y^2*z + y*z^2
  5*y^3 + 4*y^2*z - y*z^2
  6*x*y^2 + 5*y^2*z - y*z^2
  6*x^2*y + 5*y^2*z - y*z^2
  25*x^3 - x*z^2 + 20*y^2*z - 4*y*z^2

julia> PC, pr = quo(S, ideal([F]));

julia> psi = hom(P5, PC, [pr(K[i]) for i = 1:6]);

julia> J = kernel(psi);

julia> JJ = ideal(minimal_generating_set(J));

julia> Q , _ = quo(P5, JJ);

julia> re = free_resolution(Q);

julia> minimal_betti_table(re)
       0  1   2  3  4
---------------------
0    : 1  -   -  -  -
1    : -  6   5  -  -
2    : -  -   5  6  -
3    : -  -   -  -  1
---------------------
total: 1  6  10  6  1
```

```julia
julia> K = GF(3);

julia> S, (x0, x1, x2, x3, x4) = graded_polynomial_ring(K, ["x0", "x1", "x2", "x3", "x4"]);

julia> m = ideal(S, [x1^2+(-x1+x2+x3-x4)*x0, x1*x2+(x1-x3+x4)*x0, x1*x3+(-x1+x4+x0)*x0, x1*x4+(-x1+x3+x4-x0)*x0, x2^2+(x1-x2-x4-x0)*x0, x2*x3+(x1-x2+x3+x4-x0)*x0, x2*x4+(x1+x2-x3-x4-x0)*x0, x3^2+(x3+x4-x0)*x0,x3*x4+(-x3-x4+x0)*x0, x4^2+(x1+x3-x4-x0)*x0]);

julia> R, _ = quo(S, m);

julia> FR = free_resolution(R, algorithm = :mres);

julia> L = monomial_basis(R, 2)
5-element Vector{MPolyDecRingElem{FqFieldElem, FqMPolyRingElem}}:
 x4^2
 x3*x4
 x2*x4
 x2*x3
 x1*x4

julia> versal_unfolding = [[i == div((j-1), 5) + 1 ? S(L[(j-1) % 5 + 1]) : S(0) for i in 1:10] for j in 1:50];

julia> function normal_space_generator(FR, A1t)
         phi1 = map(FR, 1)
         e1 = gen(codomain(phi1),1)
         phi2 = map(FR, 2)
         phi3 = map(FR, 3)
         A1 = hom(domain(phi1), codomain(phi1), [p*e1 for p in A1t])
         A1phi2 = phi2 * A1
         A2 = lift(A1phi2, phi1)
         A2phi3 = phi3 * A2
         A3 = lift(A2phi3, phi2)
         A3m = matrix(A3)
         return A3m[1:2, 16:22]
       end;

julia> nlist = [normal_space_generator(FR, v) for v in versal_unfolding];

julia> TS, t = graded_polynomial_ring(K, "t"=>(1:50));

julia> nlist_t = [map_entries(x -> x * t[i], map_entries(constant_coefficient, nlist[i])) for i in 1:50];

julia> B = sum(nlist_t);

julia> tangent_space = ideal(vec(collect(B)));

julia> ngens(leading_ideal(tangent_space))
14
```

```julia
julia> k = GF(31991);

julia> S, (x, y, z, t) = polynomial_ring(k, ["x", "y", "z", "t"]);

julia> a, b, c = 40, 30, 8
(40, 30, 8)

julia> ft=x^a+y^b+z^(3*c)+x^(c+2)*y^(c-1)+x^(c-1)*y^(c-1)*z^3+x^(c-2)*y^c*(y^2+t*x)^2;

julia> R, (x, y, z) = polynomial_ring(k, ["x", "y", "z"]);

julia> f0 = hom(S, R, [x, y, z, 0])(ft);

julia> f1 = hom(S, R, [x, y, z, 1])(ft);

julia> MI0 = jacobian_ideal(f0);    MI1 = jacobian_ideal(f1);

julia> U = complement_of_point_ideal(R, [0 ,0, 0]);

julia> Rloc, phi = localization(R, U);

julia> A0, _ = quo(Rloc, phi(MI0));  A1, _ = quo(Rloc, phi(MI1));

julia> vector_space_dimension(A0)
10661

julia> vector_space_dimension(A1)
10655
```
